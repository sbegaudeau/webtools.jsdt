<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_12) on Fri May 30 11:16:00 CDT 2008 -->
<TITLE>
SearchPattern
</TITLE>

<META NAME="keywords" CONTENT="org.eclipse.wst.jsdt.core.search.SearchPattern class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="SearchPattern";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SearchPattern.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchParticipant.html" title="class in org.eclipse.wst.jsdt.core.search"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchRequestor.html" title="class in org.eclipse.wst.jsdt.core.search"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?org/eclipse/wst/jsdt/core/search/SearchPattern.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SearchPattern.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.eclipse.wst.jsdt.core.search</FONT>
<BR>
Class SearchPattern</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../../resources/inherit.gif" ALT="extended by ">org.eclipse.wst.jsdt.internal.core.search.matching.InternalSearchPattern
      <IMG SRC="../../../../../../resources/inherit.gif" ALT="extended by "><B>org.eclipse.wst.jsdt.core.search.SearchPattern</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>SearchPattern</B><DT>extends org.eclipse.wst.jsdt.internal.core.search.matching.InternalSearchPattern</DL>
</PRE>

<P>
A search pattern defines how search results are found. Use <code>SearchPattern.createPattern</code>
 to create a search pattern.
 <p>
 Search patterns are used during the search phase to decode index entries that were added during the indexing phase
 (see <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchDocument.html#addIndexEntry(char[], char[])"><CODE>SearchDocument.addIndexEntry(char[], char[])</CODE></A>). When an index is queried, the
 index categories and keys to consider are retrieved from the search pattern using <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getIndexCategories()"><CODE>getIndexCategories()</CODE></A> and
 <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getIndexKey()"><CODE>getIndexKey()</CODE></A>, as well as the match rule (see <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getMatchRule()"><CODE>getMatchRule()</CODE></A>). A blank pattern is
 then created (see <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getBlankPattern()"><CODE>getBlankPattern()</CODE></A>). This blank pattern is used as a record as follows.
 For each index entry in the given index categories and that starts with the given key, the blank pattern is fed using
 <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#decodeIndexKey(char[])"><CODE>decodeIndexKey(char[])</CODE></A>. The original pattern is then asked if it matches the decoded key using
 <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#matchesDecodedKey(org.eclipse.wst.jsdt.core.search.SearchPattern)"><CODE>matchesDecodedKey(SearchPattern)</CODE></A>. If it matches, a search doument is created for this index entry
 using <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchParticipant.html#getDocument(java.lang.String)"><CODE>SearchParticipant.getDocument(String)</CODE></A>.

 </p><p>
 This class is intended to be subclassed by clients. A default behavior is provided for each of the methods above, that
 clients can ovveride if they wish.
 </p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int)"><CODE>createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int)</CODE></A>, 
<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createPattern(java.lang.String, int, int, int)"><CODE>Provisional API: This class/interface is part of an interim API that is still under development and expected to 
 change significantly before reaching stability. It is being made available at this early stage to solicit feedback 
 from pioneering adopters on the understanding that any code that uses this API will almost certainly be broken 
 (repeatedly) as the API evolves.</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH">R_CAMELCASE_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern contains a Camel Case expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE">R_CASE_SENSITIVE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern matches the search result only if cases are the same.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH">R_EQUIVALENT_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern matches search results as raw/parameterized types/methods with equivalent type parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH">R_ERASURE_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern matches search results as raw/parameterized types/methods with same erasure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH">R_EXACT_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern matches exactly the search result,
 that is, the source of the search result equals the search pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_FULL_MATCH">R_FULL_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern matches exactly the search result,
 that is, the source of the search result equals the search pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH">R_PATTERN_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern contains one or more wild cards ('*' or '?').</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH">R_PREFIX_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern is a prefix of the search result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_REGEXP_MATCH">R_REGEXP_MATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match rule: The search pattern contains a regular expression.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#SearchPattern(int)">SearchPattern</A></B>(int&nbsp;matchRule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a search pattern with the rule to apply for matching index keys.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#camelCaseMatch(java.lang.String, int, int, java.lang.String, int, int)">camelCaseMatch</A></B>(java.lang.String&nbsp;pattern,
               int&nbsp;patternStart,
               int&nbsp;patternEnd,
               java.lang.String&nbsp;name,
               int&nbsp;nameStart,
               int&nbsp;nameEnd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if a sub-pattern matches the subpart of the given name using CamelCase rules, or false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#camelCaseMatch(java.lang.String, java.lang.String)">camelCaseMatch</A></B>(java.lang.String&nbsp;pattern,
               java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the pattern matches the given name using CamelCase rules, or false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createAndPattern(org.eclipse.wst.jsdt.core.search.SearchPattern, org.eclipse.wst.jsdt.core.search.SearchPattern)">createAndPattern</A></B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;leftPattern,
                 <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;rightPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a search pattern that combines the given two patterns into an
 "and" pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createOrPattern(org.eclipse.wst.jsdt.core.search.SearchPattern, org.eclipse.wst.jsdt.core.search.SearchPattern)">createOrPattern</A></B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;leftPattern,
                <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;rightPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a search pattern that combines the given two patterns into an
 "or" pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int)">createPattern</A></B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/IJavaScriptElement.html" title="interface in org.eclipse.wst.jsdt.core">IJavaScriptElement</A>&nbsp;element,
              int&nbsp;limitTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a search pattern based on a given JavaScript element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int, int)">createPattern</A></B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/IJavaScriptElement.html" title="interface in org.eclipse.wst.jsdt.core">IJavaScriptElement</A>&nbsp;element,
              int&nbsp;limitTo,
              int&nbsp;matchRule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a search pattern based on a given JavaScript element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createPattern(java.lang.String, int, int, int)">createPattern</A></B>(java.lang.String&nbsp;stringPattern,
              int&nbsp;searchFor,
              int&nbsp;limitTo,
              int&nbsp;matchRule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a search pattern based on a given string pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#decodeIndexKey(char[])">decodeIndexKey</A></B>(char[]&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decode the given index key in this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getBlankPattern()">getBlankPattern</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a blank pattern that can be used as a record to decode an index key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getIndexCategories()">getIndexCategories</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of index categories to consider for this index query.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getIndexKey()">getIndexKey</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a key to find in relevant index categories, if null then all index entries are matched.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#getMatchRule()">getMatchRule</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the rule to apply for matching index keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#matchesDecodedKey(org.eclipse.wst.jsdt.core.search.SearchPattern)">matchesDecodedKey</A></B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;decodedPattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether this pattern matches the given pattern (representing a decoded index key).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#matchesName(char[], char[])">matchesName</A></B>(char[]&nbsp;pattern,
            char[]&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the given name matches the given pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#validateMatchRule(java.lang.String, int)">validateMatchRule</A></B>(java.lang.String&nbsp;stringPattern,
                  int&nbsp;matchRule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Validate compatibility between given string pattern and match rule.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.eclipse.wst.jsdt.internal.core.search.matching.InternalSearchPattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.eclipse.wst.jsdt.internal.core.search.matching.InternalSearchPattern</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>findIndexMatches</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="R_EXACT_MATCH"><!-- --></A><H3>
R_EXACT_MATCH</H3>
<PRE>
public static final int <B>R_EXACT_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern matches exactly the search result,
 that is, the source of the search result equals the search pattern.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_EXACT_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_PREFIX_MATCH"><!-- --></A><H3>
R_PREFIX_MATCH</H3>
<PRE>
public static final int <B>R_PREFIX_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern is a prefix of the search result.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_PREFIX_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_PATTERN_MATCH"><!-- --></A><H3>
R_PATTERN_MATCH</H3>
<PRE>
public static final int <B>R_PATTERN_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern contains one or more wild cards ('*' or '?').
 A '*' wild-card can replace 0 or more characters in the search result.
 A '?' wild-card replaces exactly 1 character in the search result.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_PATTERN_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_REGEXP_MATCH"><!-- --></A><H3>
R_REGEXP_MATCH</H3>
<PRE>
public static final int <B>R_REGEXP_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern contains a regular expression.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_REGEXP_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_CASE_SENSITIVE"><!-- --></A><H3>
R_CASE_SENSITIVE</H3>
<PRE>
public static final int <B>R_CASE_SENSITIVE</B></PRE>
<DL>
<DD>Match rule: The search pattern matches the search result only if cases are the same.
 Can be combined to previous rules, e.g. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_CASE_SENSITIVE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_ERASURE_MATCH"><!-- --></A><H3>
R_ERASURE_MATCH</H3>
<PRE>
public static final int <B>R_ERASURE_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern matches search results as raw/parameterized types/methods with same erasure.
 This mode has no effect on other javascript elements search.<br>
 Type search example:
        <ul>
        <li>pattern: <code>List&lt;Exception&gt;</code></li>
        <li>match: <code>List&lt;Object&gt;</code></li>
        </ul>
 Method search example:
        <ul>
        <li>declaration: <code>&lt;T&gt;foo(T t)</code></li>
        <li>pattern: <code>&lt;Exception&gt;foo(new Exception())</code></li>
        <li>match: <code>&lt;Object&gt;foo(new Object())</code></li>
        </ul>
 Can be combined to all other match rules, e.g. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A>
 This rule is not activated by default, so raw types or parameterized types with same erasure will not be found
 for pattern List&lt;String&gt;,
 Note that with this pattern, the match selection will be only on the erasure even for parameterized types.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_ERASURE_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_EQUIVALENT_MATCH"><!-- --></A><H3>
R_EQUIVALENT_MATCH</H3>
<PRE>
public static final int <B>R_EQUIVALENT_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern matches search results as raw/parameterized types/methods with equivalent type parameters.
 This mode has no effect on other javascript elements search.<br>
 Type search example:
 <ul>
        <li>pattern: <code>List&lt;Exception&gt;</code></li>
        <li>match:
                <ul>
                <li><code>List&lt;? extends Throwable&gt;</code></li>
                <li><code>List&lt;? super RuntimeException&gt;</code></li>
                <li><code>List&lt;?&gt;</code></li>
                        </ul>
        </li>
        </ul>
 Method search example:
        <ul>
        <li>declaration: <code>&lt;T&gt;foo(T t)</code></li>
        <li>pattern: <code>&lt;Exception&gt;foo(new Exception())</code></li>
        <li>match:
                <ul>
                <li><code>&lt;? extends Throwable&gt;foo(new Exception())</code></li>
                <li><code>&lt;? super RuntimeException&gt;foo(new Exception())</code></li>
                <li><code>foo(new Exception())</code></li>
                        </ul>
        </ul>
 Can be combined to all other match rules, e.g. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A>
 This rule is not activated by default, so raw types or equivalent parameterized types will not be found
 for pattern List&lt;String&gt;,
 This mode is overridden by <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> as erasure matches obviously include equivalent ones.
 That means that pattern with rule set to <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A>
 will return same results than rule only set with <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_EQUIVALENT_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_FULL_MATCH"><!-- --></A><H3>
R_FULL_MATCH</H3>
<PRE>
public static final int <B>R_FULL_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern matches exactly the search result,
 that is, the source of the search result equals the search pattern.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_FULL_MATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="R_CAMELCASE_MATCH"><!-- --></A><H3>
R_CAMELCASE_MATCH</H3>
<PRE>
public static final int <B>R_CAMELCASE_MATCH</B></PRE>
<DL>
<DD>Match rule: The search pattern contains a Camel Case expression.
 <br>
 Examples:
 <ul>
        <li><code>NPE</code> type string pattern will match
                <code>NullPointerException</code> and <code>NpPermissionException</code> types,</li>
        <li><code>NuPoEx</code> type string pattern will only match
                <code>NullPointerException</code> type.</li>
 </ul>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../../org/eclipse/wst/jsdt/core/compiler/CharOperation.html#camelCaseMatch(char[], char[])"><CODE>for a detailed explanation
 of Camel Case matching.
<br>
 Can be combined to {@link #R_PREFIX_MATCH} match rule. For example,
 when prefix match rule is combined with Camel Case match rule,
 <code>"nPE"</code> pattern will match <code>nPException</code>.
<br>
 Match rule {@link #R_PATTERN_MATCH} may also be combined but both rules
 will not be used simultaneously as they are mutually exclusive.
 Used match rule depends on whether string pattern contains specific pattern
 characters (e.g. '*' or '?') or not. If it does, then only Pattern match rule
 will be used, otherwise only Camel Case match will be used.
 For example, with <code>"NPE"</code> string pattern, search will only use
 Camel Case match rule, but with <code>N*P*E*</code> string pattern, it will
 use only Pattern match rule.</CODE></A>, 
<A HREF="../../../../../../constant-values.html#org.eclipse.wst.jsdt.core.search.SearchPattern.R_CAMELCASE_MATCH">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SearchPattern(int)"><!-- --></A><H3>
SearchPattern</H3>
<PRE>
public <B>SearchPattern</B>(int&nbsp;matchRule)</PRE>
<DL>
<DD>Creates a search pattern with the rule to apply for matching index keys.
 It can be exact match, prefix match, pattern match or regexp match.
 Rule can also be combined with a case sensitivity flag.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>matchRule</CODE> - one of <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH"><CODE>R_PATTERN_MATCH</CODE></A>,
        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_REGEXP_MATCH"><CODE>R_REGEXP_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A> combined with one of following values:
        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A>.
                e.g. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A> if an exact and case sensitive match is requested,
                <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A> if a prefix non case sensitive match is requested or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A>
                if a non case sensitive and erasure match is requested.<br>
        Note that <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A> have no effect
        on non-generic types/methods search.<br>
        Note also that default behavior for generic types/methods search is to find exact matches.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="camelCaseMatch(java.lang.String, java.lang.String)"><!-- --></A><H3>
camelCaseMatch</H3>
<PRE>
public static final boolean <B>camelCaseMatch</B>(java.lang.String&nbsp;pattern,
                                           java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Answers true if the pattern matches the given name using CamelCase rules, or false otherwise.
 CamelCase matching does NOT accept explicit wild-cards '*' and '?' and is inherently case sensitive.
 <br>
 CamelCase denotes the convention of writing compound names without spaces, and capitalizing every term.
 This function recognizes both upper and lower CamelCase, depending whether the leading character is capitalized
 or not. The leading part of an upper CamelCase pattern is assumed to contain a sequence of capitals which are appearing
 in the matching name; e.g. 'NPE' will match 'NullPointerException', but not 'NewPerfData'. A lower CamelCase pattern
 uses a lowercase first character. In Java, type names follow the upper CamelCase convention, whereas method or field
 names follow the lower CamelCase convention.
 <br>
 The pattern may contain lowercase characters, which will be match in a case sensitive way. These characters must
 appear in sequence in the name. For instance, 'NPExcep' will match 'NullPointerException', but not 'NullPointerExCEPTION'
 or 'NuPoEx' will match 'NullPointerException', but not 'NoPointerException'.
 <br><br>
 Examples:
 <ol>
 <li><pre>
    pattern = "NPE"
    name = NullPointerException / NoPermissionException
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = "NuPoEx"
    name = NullPointerException
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = "npe"
    name = NullPointerException
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the given pattern<DD><CODE>name</CODE> - the given name
<DT><B>Returns:</B><DD>true if the pattern matches the given name, false otherwise<DT><B>See Also:</B><DD><A HREF="../../../../../../org/eclipse/wst/jsdt/core/compiler/CharOperation.html#camelCaseMatch(char[], char[])"><CODE>Implementation has been entirely copied from this method except for array lengthes
 	which were obviously replaced with calls to {@link String#length()}.</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="camelCaseMatch(java.lang.String, int, int, java.lang.String, int, int)"><!-- --></A><H3>
camelCaseMatch</H3>
<PRE>
public static final boolean <B>camelCaseMatch</B>(java.lang.String&nbsp;pattern,
                                           int&nbsp;patternStart,
                                           int&nbsp;patternEnd,
                                           java.lang.String&nbsp;name,
                                           int&nbsp;nameStart,
                                           int&nbsp;nameEnd)</PRE>
<DL>
<DD>Answers true if a sub-pattern matches the subpart of the given name using CamelCase rules, or false otherwise.
 CamelCase matching does NOT accept explicit wild-cards '*' and '?' and is inherently case sensitive.
 Can match only subset of name/pattern, considering end positions as non-inclusive.
 The subpattern is defined by the patternStart and patternEnd positions.
 <br>
 CamelCase denotes the convention of writing compound names without spaces, and capitalizing every term.
 This function recognizes both upper and lower CamelCase, depending whether the leading character is capitalized
 or not. The leading part of an upper CamelCase pattern is assumed to contain a sequence of capitals which are appearing
 in the matching name; e.g. 'NPE' will match 'NullPointerException', but not 'NewPerfData'. A lower CamelCase pattern
 uses a lowercase first character. In Java, type names follow the upper CamelCase convention, whereas method or field
 names follow the lower CamelCase convention.
 <br>
 The pattern may contain lowercase characters, which will be match in a case sensitive way. These characters must
 appear in sequence in the name. For instance, 'NPExcep' will match 'NullPointerException', but not 'NullPointerExCEPTION'
 or 'NuPoEx' will match 'NullPointerException', but not 'NoPointerException'.
 <br><br>
 Examples:
 <ol>
 <li><pre>
    pattern = "NPE"
    patternStart = 0
    patternEnd = 3
    name = NullPointerException
    nameStart = 0
    nameEnd = 20
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = "NPE"
    patternStart = 0
    patternEnd = 3
    name = NoPermissionException
    nameStart = 0
    nameEnd = 21
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = "NuPoEx"
    patternStart = 0
    patternEnd = 6
    name = NullPointerException
    nameStart = 0
    nameEnd = 20
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = "NuPoEx"
    patternStart = 0
    patternEnd = 6
    name = NoPermissionException
    nameStart = 0
    nameEnd = 21
    result => false
 </pre>
 </li>
 <li><pre>
    pattern = "npe"
    patternStart = 0
    patternEnd = 3
    name = NullPointerException
    nameStart = 0
    nameEnd = 20
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the given pattern<DD><CODE>patternStart</CODE> - the start index of the pattern, inclusive<DD><CODE>patternEnd</CODE> - the end index of the pattern, exclusive<DD><CODE>name</CODE> - the given name<DD><CODE>nameStart</CODE> - the start index of the name, inclusive<DD><CODE>nameEnd</CODE> - the end index of the name, exclusive
<DT><B>Returns:</B><DD>true if a sub-pattern matches the subpart of the given name, false otherwise<DT><B>See Also:</B><DD><A HREF="../../../../../../org/eclipse/wst/jsdt/core/compiler/CharOperation.html#camelCaseMatch(char[], int, int, char[], int, int)"><CODE>Implementation has been entirely copied from this method except for array lengthes
 	which were obviously replaced with calls to {@link String#length()} and
 	for array direct access which were replaced with calls to {@link String#charAt(int)}.</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createAndPattern(org.eclipse.wst.jsdt.core.search.SearchPattern, org.eclipse.wst.jsdt.core.search.SearchPattern)"><!-- --></A><H3>
createAndPattern</H3>
<PRE>
public static <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A> <B>createAndPattern</B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;leftPattern,
                                             <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;rightPattern)</PRE>
<DL>
<DD>Returns a search pattern that combines the given two patterns into an
 "and" pattern. The search result will match both the left pattern and
 the right pattern.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>leftPattern</CODE> - the left pattern<DD><CODE>rightPattern</CODE> - the right pattern
<DT><B>Returns:</B><DD>an "and" pattern</DL>
</DD>
</DL>
<HR>

<A NAME="createOrPattern(org.eclipse.wst.jsdt.core.search.SearchPattern, org.eclipse.wst.jsdt.core.search.SearchPattern)"><!-- --></A><H3>
createOrPattern</H3>
<PRE>
public static <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A> <B>createOrPattern</B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;leftPattern,
                                            <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;rightPattern)</PRE>
<DL>
<DD>Returns a search pattern that combines the given two patterns into an
 "or" pattern. The search result will match either the left pattern or the
 right pattern.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>leftPattern</CODE> - the left pattern<DD><CODE>rightPattern</CODE> - the right pattern
<DT><B>Returns:</B><DD>an "or" pattern</DL>
</DD>
</DL>
<HR>

<A NAME="createPattern(java.lang.String, int, int, int)"><!-- --></A><H3>
createPattern</H3>
<PRE>
public static <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A> <B>createPattern</B>(java.lang.String&nbsp;stringPattern,
                                          int&nbsp;searchFor,
                                          int&nbsp;limitTo,
                                          int&nbsp;matchRule)</PRE>
<DL>
<DD>Returns a search pattern based on a given string pattern. The string patterns support '*' wild-cards.
 The remaining parameters are used to narrow down the type of expected results.

 <br>
        Examples:
        <ul>
                <li>search for case insensitive references to <code>Object</code>:
                        <code>createSearchPattern("Object", TYPE, REFERENCES, false);</code></li>
        <li>search for case sensitive references to exact <code>Object()</code> constructor:
                        <code>createSearchPattern("java.lang.Object()", CONSTRUCTOR, REFERENCES, true);</code></li>
        <li>search for implementers of <code>java.lang.Runnable</code>:
                        <code>createSearchPattern("java.lang.Runnable", TYPE, IMPLEMENTORS, true);</code></li>
  </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stringPattern</CODE> - the given pattern<DD><CODE>searchFor</CODE> - determines the nature of the searched elements
        <ul>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#CLASS"><CODE>IJavaScriptSearchConstants.CLASS</CODE></A>: only look for classes</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#INTERFACE"><CODE>IJavaScriptSearchConstants.INTERFACE</CODE></A>: only look for interfaces</li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#ENUM"><CODE>IJavaScriptSearchConstants.ENUM</CODE></A>: only look for enumeration</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#ANNOTATION_TYPE"><CODE>IJavaScriptSearchConstants.ANNOTATION_TYPE</CODE></A>: only look for annotation type</li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#CLASS_AND_ENUM"><CODE>IJavaScriptSearchConstants.CLASS_AND_ENUM</CODE></A>: only look for classes and enumerations</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#CLASS_AND_INTERFACE"><CODE>IJavaScriptSearchConstants.CLASS_AND_INTERFACE</CODE></A>: only look for classes and interfaces</li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#TYPE"><CODE>IJavaScriptSearchConstants.TYPE</CODE></A>: look for all types (ie. classes, interfaces, enum and annotation types)</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#FIELD"><CODE>IJavaScriptSearchConstants.FIELD</CODE></A>: look for fields</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#METHOD"><CODE>IJavaScriptSearchConstants.METHOD</CODE></A>: look for methods</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#CONSTRUCTOR"><CODE>IJavaScriptSearchConstants.CONSTRUCTOR</CODE></A>: look for constructors</li>
                <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#PACKAGE"><CODE>IJavaScriptSearchConstants.PACKAGE</CODE></A>: look for packages</li>
        </ul><DD><CODE>limitTo</CODE> - determines the nature of the expected matches
        <ul>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#DECLARATIONS"><CODE>IJavaScriptSearchConstants.DECLARATIONS</CODE></A>: will search declarations matching
                        with the corresponding element. In case the element is a method, declarations of matching
                        methods in subtypes will also be found, allowing to find declarations of abstract methods, etc.<br>
                        Note that additional flags <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IGNORE_DECLARING_TYPE"><CODE>IJavaScriptSearchConstants.IGNORE_DECLARING_TYPE</CODE></A> and
                        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IGNORE_RETURN_TYPE"><CODE>IJavaScriptSearchConstants.IGNORE_RETURN_TYPE</CODE></A> are ignored for string patterns.
                        This is due to the fact that client may omit to define them in string pattern to have same behavior.
        </li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#REFERENCES"><CODE>IJavaScriptSearchConstants.REFERENCES</CODE></A>: will search references to the given element.</li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#ALL_OCCURRENCES"><CODE>IJavaScriptSearchConstants.ALL_OCCURRENCES</CODE></A>: will search for either declarations or
                                references as specified above.
                </li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IMPLEMENTORS"><CODE>IJavaScriptSearchConstants.IMPLEMENTORS</CODE></A>: for types, will find all types
                                which directly implement/extend a given interface.
                                Note that types may be only classes or only interfaces if <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#CLASS"><CODE>IJavaScriptSearchConstants.CLASS</CODE></A> or
                                <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#INTERFACE"><CODE>IJavaScriptSearchConstants.INTERFACE</CODE></A> is respectively used instead of <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#TYPE"><CODE>IJavaScriptSearchConstants.TYPE</CODE></A>.
                </li>
        </ul><DD><CODE>matchRule</CODE> - one of <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH"><CODE>R_PATTERN_MATCH</CODE></A>,
        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_REGEXP_MATCH"><CODE>R_REGEXP_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A> combined with one of following values:
        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A>.
                e.g. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A> if an exact and case sensitive match is requested,
                <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A> if a prefix non case sensitive match is requested or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A>
                if a non case sensitive and erasure match is requested.<br>
        Note that <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A> have no effect
        on non-generic types/methods search.<br>
        Note also that default behavior for generic types/methods search is to find exact matches.
<DT><B>Returns:</B><DD>a search pattern on the given string pattern, or <code>null</code> if the string pattern is ill-formed</DL>
</DD>
</DL>
<HR>

<A NAME="createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int)"><!-- --></A><H3>
createPattern</H3>
<PRE>
public static <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A> <B>createPattern</B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/IJavaScriptElement.html" title="interface in org.eclipse.wst.jsdt.core">IJavaScriptElement</A>&nbsp;element,
                                          int&nbsp;limitTo)</PRE>
<DL>
<DD>Returns a search pattern based on a given JavaScript element.
 The pattern is used to trigger the appropriate search.
 <br>
 Note that for generic searches, the returned pattern consider <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> matches.
 If other kind of generic matches (ie. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A>)
 are expected, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int, int)"><CODE>createPattern(IJavaScriptElement, int, int)</CODE></A> method need to be used instead with
 the explicit match rule specified.
 <br>
 The pattern can be parameterized as follows:
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>element</CODE> - the JavaScript element the search pattern is based on<DD><CODE>limitTo</CODE> - determines the nature of the expected matches
        <ul>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#DECLARATIONS"><CODE>IJavaScriptSearchConstants.DECLARATIONS</CODE></A>: will search declarations matching
                        with the corresponding element. In case the element is a method, declarations of matching
                        methods in subtypes will also be found, allowing to find declarations of abstract methods, etc.
                                Some additional flags may be specified while searching declaration:
                                <ul>
                                        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IGNORE_DECLARING_TYPE"><CODE>IJavaScriptSearchConstants.IGNORE_DECLARING_TYPE</CODE></A>: declaring type will be ignored
                                                        during the search.<br>
                                                        For example using following test case:
                                        <pre>
                  class A { A method() { return null; } }
                  class B extends A { B method() { return null; } }
                  class C { A method() { return null; } }
                                        </pre>
                                                        search for <code>method</code> declaration with this flag
                                                        will return 2 matches: in A and in C
                                        </li>
                                        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IGNORE_RETURN_TYPE"><CODE>IJavaScriptSearchConstants.IGNORE_RETURN_TYPE</CODE></A>: return type will be ignored
                                                        during the search.<br>
                                                        Using same example, search for <code>method</code> declaration with this flag
                                                        will return 2 matches: in A and in B.
                                        </li>
                                </ul>
                                Note that these two flags may be combined and both declaring and return types can be ignored
                                during the search. Then, using same example, search for <code>method</code> declaration
                                with these 2 flags will return 3 matches: in A, in B  and in C
        </li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#REFERENCES"><CODE>IJavaScriptSearchConstants.REFERENCES</CODE></A>: will search references to the given element.</li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#ALL_OCCURRENCES"><CODE>IJavaScriptSearchConstants.ALL_OCCURRENCES</CODE></A>: will search for either declarations or
                                references as specified above.
                </li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IMPLEMENTORS"><CODE>IJavaScriptSearchConstants.IMPLEMENTORS</CODE></A>: for types, will find all types
                                which directly implement/extend a given interface.
                </li>
        </ul>
<DT><B>Returns:</B><DD>a search pattern for a JavaScript element or <code>null</code> if the given element is ill-formed</DL>
</DD>
</DL>
<HR>

<A NAME="createPattern(org.eclipse.wst.jsdt.core.IJavaScriptElement, int, int)"><!-- --></A><H3>
createPattern</H3>
<PRE>
public static <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A> <B>createPattern</B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/IJavaScriptElement.html" title="interface in org.eclipse.wst.jsdt.core">IJavaScriptElement</A>&nbsp;element,
                                          int&nbsp;limitTo,
                                          int&nbsp;matchRule)</PRE>
<DL>
<DD>Returns a search pattern based on a given JavaScript element.
 The pattern is used to trigger the appropriate search, and can be parameterized as follows:
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>element</CODE> - the JavaScript element the search pattern is based on<DD><CODE>limitTo</CODE> - determines the nature of the expected matches
        <ul>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#DECLARATIONS"><CODE>IJavaScriptSearchConstants.DECLARATIONS</CODE></A>: will search declarations matching
                        with the corresponding element. In case the element is a method, declarations of matching
                        methods in subtypes will also be found, allowing to find declarations of abstract methods, etc.
                                Some additional flags may be specified while searching declaration:
                                <ul>
                                        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IGNORE_DECLARING_TYPE"><CODE>IJavaScriptSearchConstants.IGNORE_DECLARING_TYPE</CODE></A>: declaring type will be ignored
                                                        during the search.<br>
                                                        For example using following test case:
                                        <pre>
                  class A { A method() { return null; } }
                  class B extends A { B method() { return null; } }
                  class C { A method() { return null; } }
                                        </pre>
                                                        search for <code>method</code> declaration with this flag
                                                        will return 2 matches: in A and in C
                                        </li>
                                        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IGNORE_RETURN_TYPE"><CODE>IJavaScriptSearchConstants.IGNORE_RETURN_TYPE</CODE></A>: return type will be ignored
                                                        during the search.<br>
                                                        Using same example, search for <code>method</code> declaration with this flag
                                                        will return 2 matches: in A and in B.
                                        </li>
                                </ul>
                                Note that these two flags may be combined and both declaring and return types can be ignored
                                during the search. Then, using same example, search for <code>method</code> declaration
                                with these 2 flags will return 3 matches: in A, in B  and in C
        </li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#REFERENCES"><CODE>IJavaScriptSearchConstants.REFERENCES</CODE></A>: will search references to the given element.</li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#ALL_OCCURRENCES"><CODE>IJavaScriptSearchConstants.ALL_OCCURRENCES</CODE></A>: will search for either declarations or
                                references as specified above.
                </li>
                 <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/IJavaScriptSearchConstants.html#IMPLEMENTORS"><CODE>IJavaScriptSearchConstants.IMPLEMENTORS</CODE></A>: for types, will find all types
                                which directly implement/extend a given interface.
                </li>
        </ul><DD><CODE>matchRule</CODE> - one of <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH"><CODE>R_PATTERN_MATCH</CODE></A>,
        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_REGEXP_MATCH"><CODE>R_REGEXP_MATCH</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A> combined with one of following values:
        <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A>, <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A>.
                e.g. <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> | <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A> if an exact and case sensitive match is requested,
                <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A> if a prefix non case sensitive match is requested or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EXACT_MATCH"><CODE>R_EXACT_MATCH</CODE></A> |<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A>
                if a non case sensitive and erasure match is requested.<br>
        Note that <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_ERASURE_MATCH"><CODE>R_ERASURE_MATCH</CODE></A> or <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_EQUIVALENT_MATCH"><CODE>R_EQUIVALENT_MATCH</CODE></A> have no effect on non-generic types
        or methods search.<br>
        Note also that default behavior for generic types or methods is to find exact matches.
<DT><B>Returns:</B><DD>a search pattern for a JavaScript element or <code>null</code> if the given element is ill-formed</DL>
</DD>
</DL>
<HR>

<A NAME="decodeIndexKey(char[])"><!-- --></A><H3>
decodeIndexKey</H3>
<PRE>
public void <B>decodeIndexKey</B>(char[]&nbsp;key)</PRE>
<DL>
<DD>Decode the given index key in this pattern. The decoded index key is used by
 <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#matchesDecodedKey(org.eclipse.wst.jsdt.core.search.SearchPattern)"><CODE>matchesDecodedKey(SearchPattern)</CODE></A> to find out if the corresponding index entry
 should be considered.
 <p>
 This method should be re-implemented in subclasses that need to decode an index key.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the given index key</DL>
</DD>
</DL>
<HR>

<A NAME="getBlankPattern()"><!-- --></A><H3>
getBlankPattern</H3>
<PRE>
public abstract <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A> <B>getBlankPattern</B>()</PRE>
<DL>
<DD>Returns a blank pattern that can be used as a record to decode an index key.
 <p>
 Implementors of this method should return a new search pattern that is going to be used
 to decode index keys.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a new blank pattern<DT><B>See Also:</B><DD><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#decodeIndexKey(char[])"><CODE>decodeIndexKey(char[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getIndexKey()"><!-- --></A><H3>
getIndexKey</H3>
<PRE>
public char[] <B>getIndexKey</B>()</PRE>
<DL>
<DD>Returns a key to find in relevant index categories, if null then all index entries are matched.
 The key will be matched according to some match rule. These potential matches
 will be further narrowed by the match locator, but precise match locating can be expensive,
 and index query should be as accurate as possible so as to eliminate obvious false hits.
 <p>
 This method should be re-implemented in subclasses that need to narrow down the
 index query.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an index key from this pattern, or <code>null</code> if all index entries are matched.</DL>
</DD>
</DL>
<HR>

<A NAME="getIndexCategories()"><!-- --></A><H3>
getIndexCategories</H3>
<PRE>
public char[][] <B>getIndexCategories</B>()</PRE>
<DL>
<DD>Returns an array of index categories to consider for this index query.
 These potential matches will be further narrowed by the match locator, but precise
 match locating can be expensive, and index query should be as accurate as possible
 so as to eliminate obvious false hits.
 <p>
 This method should be re-implemented in subclasses that need to narrow down the
 index query.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an array of index categories</DL>
</DD>
</DL>
<HR>

<A NAME="getMatchRule()"><!-- --></A><H3>
getMatchRule</H3>
<PRE>
public final int <B>getMatchRule</B>()</PRE>
<DL>
<DD>Returns the rule to apply for matching index keys. Can be exact match, prefix match, pattern match or regexp match.
 Rule can also be combined with a case sensitivity flag.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of R_EXACT_MATCH, R_PREFIX_MATCH, R_PATTERN_MATCH, R_REGEXP_MATCH combined with R_CASE_SENSITIVE,
   e.g. R_EXACT_MATCH | R_CASE_SENSITIVE if an exact and case sensitive match is requested,
   or R_PREFIX_MATCH if a prefix non case sensitive match is requested.
 [TODO (frederic) I hope R_ERASURE_MATCH doesn't need to be on this list. Because it would be a breaking API change.]</DL>
</DD>
</DL>
<HR>

<A NAME="matchesDecodedKey(org.eclipse.wst.jsdt.core.search.SearchPattern)"><!-- --></A><H3>
matchesDecodedKey</H3>
<PRE>
public boolean <B>matchesDecodedKey</B>(<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html" title="class in org.eclipse.wst.jsdt.core.search">SearchPattern</A>&nbsp;decodedPattern)</PRE>
<DL>
<DD>Returns whether this pattern matches the given pattern (representing a decoded index key).
 <p>
 This method should be re-implemented in subclasses that need to narrow down the
 index query.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>decodedPattern</CODE> - a pattern representing a decoded index key
<DT><B>Returns:</B><DD>whether this pattern matches the given pattern</DL>
</DD>
</DL>
<HR>

<A NAME="matchesName(char[], char[])"><!-- --></A><H3>
matchesName</H3>
<PRE>
public boolean <B>matchesName</B>(char[]&nbsp;pattern,
                           char[]&nbsp;name)</PRE>
<DL>
<DD>Returns whether the given name matches the given pattern.
 <p>
 This method should be re-implemented in subclasses that need to define how
 a name matches a pattern.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the given pattern, or <code>null</code> to represent "*"<DD><CODE>name</CODE> - the given name
<DT><B>Returns:</B><DD>whether the given name matches the given pattern</DL>
</DD>
</DL>
<HR>

<A NAME="validateMatchRule(java.lang.String, int)"><!-- --></A><H3>
validateMatchRule</H3>
<PRE>
public static int <B>validateMatchRule</B>(java.lang.String&nbsp;stringPattern,
                                    int&nbsp;matchRule)</PRE>
<DL>
<DD>Validate compatibility between given string pattern and match rule.
<br>
 Optimized (ie. returned match rule is modified) combinations are:
 <ul>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH"><CODE>R_PATTERN_MATCH</CODE></A> without any '*' or '?' in string pattern:
                pattern match bit is unset,
        </li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH"><CODE>R_PATTERN_MATCH</CODE></A> and <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A>  bits simultaneously set:
                prefix match bit is unset,
        </li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PATTERN_MATCH"><CODE>R_PATTERN_MATCH</CODE></A> and <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A>  bits simultaneously set:
                camel case match bit is unset,
        </li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A> with invalid combination of uppercase and lowercase characters:
                camel case match bit is unset and replaced with prefix match pattern,
        </li>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A> combined with <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_PREFIX_MATCH"><CODE>R_PREFIX_MATCH</CODE></A> and <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CASE_SENSITIVE"><CODE>R_CASE_SENSITIVE</CODE></A>
                bits is reduced to only <A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_CAMELCASE_MATCH"><CODE>R_CAMELCASE_MATCH</CODE></A> as Camel Case search is already prefix and case sensitive,
        </li>
 </ul>
<br>
 Rejected (ie. returned match rule -1) combinations are:
 <ul>
        <li><A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchPattern.html#R_REGEXP_MATCH"><CODE>R_REGEXP_MATCH</CODE></A> with any other match mode bit set,
        </li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stringPattern</CODE> - The string pattern<DD><CODE>matchRule</CODE> - The match rule
<DT><B>Returns:</B><DD>Optimized valid match rule or -1 if an incompatibility was detected.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><CODE>Object.toString()</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SearchPattern.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchParticipant.html" title="class in org.eclipse.wst.jsdt.core.search"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../org/eclipse/wst/jsdt/core/search/SearchRequestor.html" title="class in org.eclipse.wst.jsdt.core.search"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?org/eclipse/wst/jsdt/core/search/SearchPattern.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SearchPattern.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
